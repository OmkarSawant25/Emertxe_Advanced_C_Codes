1. Static Declaration of 2D Array
  ğŸ”¹ Key Points to Remember
    âœ… Size fixed at compile time
    âœ… Stored in stack memory
    âœ… Faster access than dynamic arrays
    âœ… Can be partially initialized
    âœ… Stored in row-major order

2. Dynamic 2D Arrays in C -> Array of Pointers (Row-wise Allocation)
  ğŸ”¹ Key Points to Remember
    âœ… Each row is a separate array, pointed to by an array of pointers.
    âœ… Memory: Heap (allocated with malloc)
    âœ… Access: arr[i][j] (easy and natural syntax)
    âœ… Dynamic Size: Both rows and columns can be determined at runtime.
    âœ… Memory Layout: Rows can be non-contiguous.
    âœ… Free Memory: Must free each row, then the array of pointers.
    âœ… Pros: Easy syntax, flexible, supports jagged arrays (different row lengths)
    âœ… Cons: Slightly slower than contiguous memory for large arrays

3. Pointer to an Array (Contiguous Row-wise Allocation)
  ğŸ”¹ Key Points to Remember
    âœ… Pointer points to a whole row (or array).
    âœ… Memory can be allocated statically or dynamically.
    âœ… Access: p[i][j] (same as normal 2D array).
    âœ… Pointer arithmetic: p + 1 moves to next row.
    âœ… Memory Layout: Rows are contiguous (especially for static arrays).
    âœ… Dynamic Allocation: Allocate rows Ã— sizeof(row) in one block.
    âœ… Pros: Good cache performance, simple arithmetic, contiguous memory.
    âœ… Cons: Less flexible for jagged arrays (all rows must have same size).

4. Array of Pointers (Dynamic, Row-wise Allocation, Jagged Arrays)
  ğŸ”¹ Key Points to Remember
    âœ… Each row is a separate array, pointed to by an array of pointers.
    âœ… Memory: Heap (allocated with malloc).
    âœ… Access: arr[i][j] (same syntax as normal 2D array).
    âœ… Dynamic Size: Both rows and columns can vary at runtime.
    âœ… Memory Layout: Rows can be non-contiguous.
    âœ… Free Memory: Must free each row, then the array of pointers.
    âœ… Pros: Flexible, supports jagged arrays (different row lengths).
    âœ… Cons: Slightly slower than contiguous memory for large arrays due to pointer indirection.

-------------------------------------------------------------------------------------------------------
1ï¸âƒ£ Static Declaration of 2D Array
-------------------------------------------------------------------------------------------------------

ğŸ”¹ Key Points to Remember

âœ… Size fixed at compile time
âœ… Stored in stack memory
âœ… Faster access than dynamic arrays
âœ… Can be partially initialized
âœ… Stored in row-major order
âœ… Contiguous memory (good for cache performance)

Example:

int arr[3][4] = {
    {1,2,3,4},
    {5,6,7,8},
    {9,10,11,12}
};

printf("%d", arr[1][2]); // Access 2nd row, 3rd column

-------------------------------------------------------------------------------------------------------
2ï¸âƒ£ Dynamic 2D Array â€“ Pointer to Array (Contiguous Row-wise Allocation)
-------------------------------------------------------------------------------------------------------

ğŸ”¹ Key Points to Remember

âœ… Pointer points to whole row
âœ… Memory: Heap, allocated in a single block
âœ… Access: p[i][j] (same syntax as normal 2D array)
âœ… Pointer arithmetic: p + 1 moves to next row
âœ… Rows are contiguous
âœ… Pros: Good cache performance, simple arithmetic
âœ… Cons: Less flexible (all rows must have same size)

Example:

int (*p)[4];               // pointer to row of 4 ints
p = malloc(sizeof(*p) * 3);  // allocate 3 rows dynamically
p[1][2] = 10;               // access 2nd row, 3rd column
free(p);                     // free memory

-------------------------------------------------------------------------------------------------------
3ï¸âƒ£ Dynamic 2D Array â€“ Array of Pointers (Row-wise Allocation / Jagged Arrays)
-------------------------------------------------------------------------------------------------------

ğŸ”¹ Key Points to Remember

âœ… Each row is a separate array, pointed to by an array of pointers
âœ… Memory: Heap, allocated row by row
âœ… Access: arr[i][j] (same syntax as normal 2D array)
âœ… Dynamic size: rows and columns can be determined at runtime
âœ… Rows can be non-contiguous
âœ… Free memory: free each row, then free the array of pointers
âœ… Pros: Flexible, supports jagged arrays (different row lengths)
âœ… Cons: Slightly slower than contiguous memory for large arrays

Example:

int *arr[3];                 // array of 3 int pointers
for(int i=0; i<3; i++)
    arr[i] = malloc(sizeof(int) * (i+2)); // each row can have different length

arr[1][2] = 10;              // access element in 2nd row, 3rd column

// Free memory
for(int i=0; i<3; i++)
    free(arr[i]);

âœ… Quick Comparison Table
| Feature                | Static 2D Array | Pointer to Array (Dynamic) | Array of Pointers (Dynamic)       |
| ---------------------- | --------------- | -------------------------- | --------------------------------- |
| Memory Allocation      | Stack           | Heap (single block)        | Heap (row by row + pointer array) |
| Contiguous Memory      | Yes             | Yes                        | No (rows may be scattered)        |
| Row Size               | Fixed           | Fixed per allocation       | Flexible / can vary               |
| Access Syntax          | `arr[i][j]`     | `p[i][j]`                  | `arr[i][j]`                       |
| Supports Jagged Arrays | No              | No                         | Yes                               |
| Free Memory            | N/A             | Single `free()`            | Free each row + pointer array     |
| Pros                   | Fast, simple    | Contiguous, cache-friendly | Flexible, supports jagged arrays  |
| Cons                   | Size fixed      | Less flexible              | Slightly slower, more management  |
